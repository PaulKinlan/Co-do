/**
 * WASM Tool Loader
 *
 * This module handles loading WASM tools from ZIP packages and from
 * the built-in registry. It validates manifests and enforces security limits.
 *
 * In production builds the Vite `wasmHashPlugin` copies WASM binaries to
 * the output directory with content-hashed filenames and writes a manifest
 * mapping original URLs → hashed URLs. The loader fetches this manifest
 * once and resolves every tool URL through it so CDN caches (Cloudflare
 * etc.) are properly busted on each deploy.
 */

import JSZip from 'jszip';
import { WasmToolManifestSchema } from './types';
import type { WasmToolManifest, StoredWasmTool, BuiltinToolConfig } from './types';
import { BUILTIN_TOOLS } from './registry';

// Security limits for ZIP validation
const MAX_ZIP_SIZE = 50 * 1024 * 1024; // 50 MB
const MAX_FILE_COUNT = 100;
const MAX_WASM_SIZE = 20 * 1024 * 1024; // 20 MB
const MAX_LAZY_WASM_SIZE = 50 * 1024 * 1024; // 50 MB (for large lazy-loaded tools like FFmpeg)

/** URL of the manifest generated by the Vite wasmHashPlugin. */
const WASM_MANIFEST_URL = 'wasm-tools/wasm-manifest.json';

/**
 * WASM Tool Loader that handles loading tools from ZIP packages
 * and from the built-in registry.
 */
export class WasmToolLoader {
  /** Cached hash manifest. `null` means not yet fetched. */
  private wasmManifest: Record<string, string> | null = null;

  /**
   * In-flight manifest fetch promise.  Stored so concurrent callers of
   * `resolveWasmUrl` share the same request instead of firing duplicates.
   */
  private manifestPromise: Promise<void> | null = null;

  /**
   * Resolve a raw WASM URL (e.g. `wasm-tools/binaries/base64.wasm`) to
   * its content-hashed equivalent if a manifest is available.
   *
   * In dev mode the Vite plugin serves an empty manifest (`{}`), so the
   * raw URL is returned as-is.
   *
   * The manifest fetch is attempted once.  If it fails due to a transient
   * network error it is retried a single time (with a 1 s delay) before
   * giving up and falling back to raw URLs for the rest of the session.
   */
  async resolveWasmUrl(rawUrl: string): Promise<string> {
    if (!this.wasmManifest && !this.manifestPromise) {
      this.manifestPromise = this.loadManifest();
    }

    if (this.manifestPromise) {
      await this.manifestPromise;
    }

    return this.wasmManifest?.[rawUrl] ?? rawUrl;
  }

  /**
   * Fetch `wasm-manifest.json`, retrying once on failure.
   */
  private async loadManifest(): Promise<void> {
    const MAX_RETRIES = 1;
    for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
      try {
        const res = await fetch(WASM_MANIFEST_URL);
        if (res.ok) {
          this.wasmManifest = await res.json();
          this.manifestPromise = null;
          return;
        }
      } catch {
        // Network error — retry if we haven't exhausted attempts
      }
      if (attempt < MAX_RETRIES) {
        await new Promise(r => setTimeout(r, 1000));
      }
    }
    // All attempts failed — fall back to raw URLs for this session.
    this.wasmManifest = {};
    this.manifestPromise = null;
  }

  /**
   * Load a single WASM tool from a ZIP archive.
   *
   * ZIP format constraints:
   * - Must contain exactly one `manifest.json` at any depth.
   * - Must contain exactly one `.wasm` file at any depth.
   * - Additional files are ignored but allowed.
   */
  async loadFromZip(zipFile: File): Promise<{
    manifest: WasmToolManifest;
    wasmBinary: ArrayBuffer;
  }> {
    // 0. Validate ZIP size
    if (zipFile.size > MAX_ZIP_SIZE) {
      throw new Error(`ZIP file exceeds maximum size of ${MAX_ZIP_SIZE / 1024 / 1024} MB`);
    }

    // 1. Read the ZIP into memory
    const zipData = await zipFile.arrayBuffer();

    // 2. Unzip the file using JSZip
    const zip = await JSZip.loadAsync(zipData);

    // 3. Validate file count to prevent ZIP bomb attacks
    const entries = Object.values(zip.files).filter((e) => !e.dir);
    if (entries.length > MAX_FILE_COUNT) {
      throw new Error(`ZIP contains too many files (max: ${MAX_FILE_COUNT})`);
    }

    let manifestFile: JSZip.JSZipObject | null = null;
    let wasmFile: JSZip.JSZipObject | null = null;

    // 4. Find manifest.json and *.wasm, enforcing "exactly one" of each
    for (const entry of entries) {
      // Path traversal protection
      if (entry.name.includes('..') || entry.name.startsWith('/')) {
        throw new Error(`Invalid file path in ZIP: ${entry.name}`);
      }

      const normalizedName = entry.name.toLowerCase();
      const fileName = normalizedName.split('/').pop() ?? '';

      if (fileName === 'manifest.json') {
        if (manifestFile !== null) {
          throw new Error('WASM tool ZIP must contain exactly one manifest.json file');
        }
        manifestFile = entry;
        continue;
      }

      if (fileName.endsWith('.wasm')) {
        if (wasmFile !== null) {
          throw new Error('WASM tool ZIP must contain exactly one .wasm file');
        }
        wasmFile = entry;
      }
    }

    if (!manifestFile) {
      throw new Error('WASM tool ZIP is missing manifest.json');
    }

    if (!wasmFile) {
      throw new Error('WASM tool ZIP is missing a .wasm file');
    }

    // 5. Load and parse manifest.json
    const manifestText = await manifestFile.async('string');
    let manifestRaw: unknown;
    try {
      manifestRaw = JSON.parse(manifestText);
    } catch {
      throw new Error('Invalid JSON in manifest.json');
    }

    // Validate manifest against schema
    const parseResult = WasmToolManifestSchema.safeParse(manifestRaw);
    if (!parseResult.success) {
      const errors = parseResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`).join(', ');
      throw new Error(`Invalid manifest: ${errors}`);
    }
    const manifest = parseResult.data;

    // 6. Load the WASM binary with size validation
    const wasmBinary = await wasmFile.async('arraybuffer');
    if (wasmBinary.byteLength > MAX_WASM_SIZE) {
      throw new Error(`WASM binary exceeds maximum size of ${MAX_WASM_SIZE / 1024 / 1024} MB`);
    }

    // 7. Validate WASM magic number
    const magic = new Uint8Array(wasmBinary.slice(0, 4));
    if (magic[0] !== 0x00 || magic[1] !== 0x61 || magic[2] !== 0x73 || magic[3] !== 0x6d) {
      throw new Error('Invalid WASM binary (bad magic number)');
    }

    // 8. Return parsed data
    return { manifest, wasmBinary };
  }

  /**
   * Load a built-in tool from the registry.
   * For tools with `enabledByDefault: false`, creates a placeholder entry
   * without downloading the binary.
   */
  async loadBuiltinTool(config: BuiltinToolConfig): Promise<StoredWasmTool> {
    // Lazy-loaded tools: create entry with empty binary, disabled
    if (config.enabledByDefault === false) {
      return this.createLazyBuiltinTool(config);
    }

    // Resolve to a content-hashed URL when available (cache busting)
    const resolvedUrl = await this.resolveWasmUrl(config.wasmUrl);
    const response = await fetch(resolvedUrl);
    if (!response.ok) {
      throw new Error(`Failed to fetch built-in tool: ${config.name} (${response.status})`);
    }

    const wasmBinary = await response.arrayBuffer();

    // Validate WASM magic number
    const magic = new Uint8Array(wasmBinary.slice(0, 4));
    if (magic[0] !== 0x00 || magic[1] !== 0x61 || magic[2] !== 0x73 || magic[3] !== 0x6d) {
      throw new Error(`Invalid WASM binary for built-in tool: ${config.name}`);
    }

    const now = Date.now();
    return {
      id: `builtin-${config.name}`,
      manifest: config.manifest,
      wasmBinary,
      source: 'builtin',
      enabled: true,
      installedAt: now,
      updatedAt: now,
    };
  }

  /**
   * Create a lazy-loaded built-in tool entry without downloading the binary.
   * The binary is downloaded on demand when the user enables the tool.
   */
  private createLazyBuiltinTool(config: BuiltinToolConfig): StoredWasmTool {
    const now = Date.now();
    return {
      id: `builtin-${config.name}`,
      manifest: config.manifest,
      wasmBinary: new ArrayBuffer(0),
      source: 'builtin',
      enabled: false,
      installedAt: now,
      updatedAt: now,
    };
  }

  /**
   * Download the WASM binary for a lazy-loaded tool.
   * Resolves the URL through the wasm-manifest.json for content-hash support
   * in production builds.
   *
   * @param wasmUrl - The raw URL (e.g., "wasm-tools/binaries/imagemagick.wasm")
   * @param toolName - Tool name for error messages
   */
  async downloadLazyBinary(wasmUrl: string, toolName: string): Promise<ArrayBuffer> {
    const resolvedUrl = await this.resolveWasmUrl(wasmUrl);
    const response = await fetch(resolvedUrl);
    if (!response.ok) {
      throw new Error(
        `Failed to download ${toolName}: HTTP ${response.status} from ${resolvedUrl}`
      );
    }

    const wasmBinary = await response.arrayBuffer();

    if (wasmBinary.byteLength === 0) {
      throw new Error(`Downloaded empty binary for ${toolName}`);
    }

    if (wasmBinary.byteLength > MAX_LAZY_WASM_SIZE) {
      throw new Error(
        `Downloaded binary for ${toolName} exceeds ${MAX_LAZY_WASM_SIZE / 1024 / 1024} MB limit`
      );
    }

    return wasmBinary;
  }

  /**
   * Load all built-in tools from the registry.
   * Returns tools that were successfully loaded; logs errors for failures.
   */
  async loadAllBuiltinTools(): Promise<StoredWasmTool[]> {
    const tools: StoredWasmTool[] = [];
    const errors: string[] = [];

    for (const config of BUILTIN_TOOLS) {
      try {
        const tool = await this.loadBuiltinTool(config);
        tools.push(tool);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        errors.push(`${config.name}: ${message}`);
        console.warn(`Failed to load built-in tool ${config.name}:`, error);
      }
    }

    if (errors.length > 0) {
      console.warn(`Failed to load ${errors.length} built-in tools:`, errors);
    }

    return tools;
  }

  /**
   * Create a StoredWasmTool from loaded data.
   */
  createStoredTool(
    manifest: WasmToolManifest,
    wasmBinary: ArrayBuffer,
    source: 'builtin' | 'user'
  ): StoredWasmTool {
    const now = Date.now();
    return {
      id: source === 'builtin' ? `builtin-${manifest.name}` : crypto.randomUUID(),
      manifest,
      wasmBinary,
      source,
      enabled: true,
      installedAt: now,
      updatedAt: now,
    };
  }

  /**
   * Get the list of built-in tool configurations.
   */
  getBuiltinToolConfigs(): BuiltinToolConfig[] {
    return BUILTIN_TOOLS;
  }
}

// Export singleton instance
export const wasmToolLoader = new WasmToolLoader();
