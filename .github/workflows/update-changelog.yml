name: Auto-Update Changelog

on:
  push:
    branches: ['main']

permissions:
  contents: write

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    # Skip if the push was made by this workflow (prevent infinite loop)
    if: github.actor != 'github-actions[bot]'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Collect commits
        id: commits
        env:
          GITHUB_EVENT_BEFORE: ${{ github.event.before }}
          GITHUB_EVENT_AFTER: ${{ github.event.after }}
        run: |
          set -euo pipefail

          BEFORE="$GITHUB_EVENT_BEFORE"
          AFTER="$GITHUB_EVENT_AFTER"

          # Handle case where BEFORE is all zeros (new branch / first push)
          if echo "$BEFORE" | grep -qE '^0+$'; then
            echo "First push to branch, using last 1 commit"
            COMMITS=$(git log -1 --pretty=format:"%s" "$AFTER")
          else
            COMMITS=$(git log --pretty=format:"%s" "${BEFORE}..${AFTER}")
          fi

          if [ -z "$COMMITS" ]; then
            echo "No new commits found. Skipping changelog update."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Skip if the only commits are changelog updates
          NON_CHANGELOG_COMMITS=$(echo "$COMMITS" | grep -v "^docs: update changelog" || true)
          if [ -z "$NON_CHANGELOG_COMMITS" ]; then
            echo "Only changelog update commits found. Skipping."
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "skip=false" >> "$GITHUB_OUTPUT"

          # Save commits to a file so later steps can read them
          echo "$NON_CHANGELOG_COMMITS" > /tmp/commits.txt

          # Also grab the full diff for Claude to use as context
          if echo "$BEFORE" | grep -qE '^0+$'; then
            git diff HEAD~1 HEAD > /tmp/diff.txt 2>/dev/null || echo "No diff available" > /tmp/diff.txt
          else
            git diff "${BEFORE}..${AFTER}" > /tmp/diff.txt 2>/dev/null || echo "No diff available" > /tmp/diff.txt
          fi

          # Truncate diff to ~10k chars to stay within API limits
          head -c 10000 /tmp/diff.txt > /tmp/diff_truncated.txt
          mv /tmp/diff_truncated.txt /tmp/diff.txt

          echo "--- Commits ---"
          cat /tmp/commits.txt

      - name: Generate friendly summary with Claude
        id: summary
        if: steps.commits.outputs.skip != 'true'
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          set -euo pipefail

          COMMITS=$(cat /tmp/commits.txt)
          DIFF=$(cat /tmp/diff.txt)

          # If no API key, skip the summary
          if [ -z "${ANTHROPIC_API_KEY:-}" ]; then
            echo "No ANTHROPIC_API_KEY found. Skipping AI summary."
            echo "has_summary=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build the prompt
          PROMPT="You are writing a changelog entry for a web app called Co-do (a browser-based collaborative coding tool).

          Given the following git commit messages and diff, write a short, friendly 1-2 sentence summary of what changed. Write it as a description that a user of the app would understand â€” avoid jargon like 'refactor' or 'WASM'. Focus on what the user gains or what was fixed.

          Do NOT use markdown formatting, bullet points, or headings. Just return the plain text summary sentences. Do not wrap in quotes.

          Commit messages:
          ${COMMITS}

          Code diff (truncated):
          ${DIFF}"

          # Escape the prompt for JSON
          JSON_PROMPT=$(jq -Rs '.' <<< "$PROMPT")

          # Call the Anthropic Messages API
          REQUEST_BODY=$(jq -n \
            --argjson prompt "$JSON_PROMPT" \
            '{
              "model": "claude-haiku-4-20250414",
              "max_tokens": 256,
              "messages": [{"role": "user", "content": $prompt}]
            }')

          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST "https://api.anthropic.com/v1/messages" \
            -H "content-type: application/json" \
            -H "x-api-key: ${ANTHROPIC_API_KEY}" \
            -H "anthropic-version: 2023-06-01" \
            -d "$REQUEST_BODY")

          HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -1)
          RESPONSE_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')

          if [ "$HTTP_STATUS" -ne 200 ]; then
            echo "Claude API returned status ${HTTP_STATUS}. Skipping AI summary."
            echo "$RESPONSE_BODY"
            echo "has_summary=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Extract the text from the response
          SUMMARY=$(echo "$RESPONSE_BODY" | jq -r '.content[0].text // empty')

          if [ -z "$SUMMARY" ]; then
            echo "Empty response from Claude. Skipping AI summary."
            echo "has_summary=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "--- Claude Summary ---"
          echo "$SUMMARY"

          # Save summary for next step
          echo "$SUMMARY" > /tmp/summary.txt
          echo "has_summary=true" >> "$GITHUB_OUTPUT"

      - name: Update CHANGELOG.md
        if: steps.commits.outputs.skip != 'true'
        env:
          HAS_SUMMARY: ${{ steps.summary.outputs.has_summary }}
        run: |
          set -euo pipefail

          NON_CHANGELOG_COMMITS=$(cat /tmp/commits.txt)

          # Categorize commits using conventional commit prefixes
          ADDED=""
          FIXED=""
          CHANGED=""
          OTHER=""

          while IFS= read -r msg; do
            # Skip changelog update commits
            if echo "$msg" | grep -q "^docs: update changelog"; then
              continue
            fi

            # Strip conventional commit prefix for the entry text
            clean_msg=$(echo "$msg" | sed -E 's/^(feat|fix|chore|docs|style|refactor|perf|test|build|ci|revert)(\(.+\))?:\s*//')
            # Capitalize first letter
            clean_msg="$(echo "${clean_msg:0:1}" | tr '[:lower:]' '[:upper:]')${clean_msg:1}"

            if echo "$msg" | grep -qE "^feat(\(.+\))?:"; then
              ADDED="${ADDED}\n- ${clean_msg}"
            elif echo "$msg" | grep -qE "^fix(\(.+\))?:"; then
              FIXED="${FIXED}\n- ${clean_msg}"
            elif echo "$msg" | grep -qE "^(refactor|perf|style)(\(.+\))?:"; then
              CHANGED="${CHANGED}\n- ${clean_msg}"
            else
              OTHER="${OTHER}\n- ${clean_msg}"
            fi
          done <<< "$NON_CHANGELOG_COMMITS"

          # Build the new entries block
          NEW_ENTRIES=""

          # Add Claude's friendly summary at the top if available
          if [ "${HAS_SUMMARY}" = "true" ] && [ -f /tmp/summary.txt ]; then
            SUMMARY=$(cat /tmp/summary.txt)
            NEW_ENTRIES="\n${SUMMARY}\n"
          fi

          if [ -n "$ADDED" ]; then
            NEW_ENTRIES="${NEW_ENTRIES}\n### Added\n${ADDED}\n"
          fi
          if [ -n "$FIXED" ]; then
            NEW_ENTRIES="${NEW_ENTRIES}\n### Fixed\n${FIXED}\n"
          fi
          if [ -n "$CHANGED" ]; then
            NEW_ENTRIES="${NEW_ENTRIES}\n### Changed\n${CHANGED}\n"
          fi
          if [ -n "$OTHER" ]; then
            NEW_ENTRIES="${NEW_ENTRIES}\n### Other\n${OTHER}\n"
          fi

          if [ -z "$NEW_ENTRIES" ]; then
            echo "No entries to add. Skipping."
            exit 0
          fi

          # Insert new entries after the ## [Unreleased] header
          # Find the line number of ## [Unreleased]
          UNRELEASED_LINE=$(grep -n "^## \[Unreleased\]" CHANGELOG.md | head -1 | cut -d: -f1)

          if [ -z "$UNRELEASED_LINE" ]; then
            echo "ERROR: Could not find ## [Unreleased] section in CHANGELOG.md"
            exit 1
          fi

          # Find the next section header after [Unreleased] (or end of file)
          NEXT_SECTION_LINE=$(tail -n +"$((UNRELEASED_LINE + 1))" CHANGELOG.md | grep -n "^## \[" | head -1 | cut -d: -f1)

          if [ -n "$NEXT_SECTION_LINE" ]; then
            # There's a next section - insert before it
            INSERT_BEFORE=$((UNRELEASED_LINE + NEXT_SECTION_LINE))
          else
            # No next section - insert at end of file (before link references)
            INSERT_BEFORE=$(grep -n "^\[Unreleased\]:" CHANGELOG.md | head -1 | cut -d: -f1)
            if [ -z "$INSERT_BEFORE" ]; then
              INSERT_BEFORE=$(($(wc -l < CHANGELOG.md) + 1))
            fi
          fi

          # Build the updated file
          # Take everything up to and including ## [Unreleased]
          head -n "$UNRELEASED_LINE" CHANGELOG.md > CHANGELOG.tmp
          # Add new entries
          echo -e "$NEW_ENTRIES" >> CHANGELOG.tmp
          # Add the rest of the file from the next section onward
          tail -n +"$INSERT_BEFORE" CHANGELOG.md >> CHANGELOG.tmp

          mv CHANGELOG.tmp CHANGELOG.md

          echo "CHANGELOG.md updated successfully."
          echo "--- New entries ---"
          echo -e "$NEW_ENTRIES"

      - name: Commit and push changes
        if: steps.commits.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md. Skipping commit."
            exit 0
          fi

          git add CHANGELOG.md
          git commit -m "docs: update changelog"
          git push
